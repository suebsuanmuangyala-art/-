function doGet(e) {
  return HtmlService.createHtmlOutputFromFile('index')
      .setTitle('ระบบจัดเก็บเอกสารราชการ')
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
      .addMetaTag('viewport', 'width=device-width, initial-scale=1.0');
}

// ==================== Configuration ====================
const SCRIPT_PROP = PropertiesService.getScriptProperties();
const FOLDER_NAME = 'Document_Attachments';

// Sheet Names
const SHEET_USERS = 'Users';
const SHEET_CATEGORIES = 'Categories';
const SHEET_DOCUMENTS = 'Documents';

// ==================== Setup & Initialization ====================
function setup() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  
  // 1. Setup Sheet: Users
  let usersSheet = ss.getSheetByName(SHEET_USERS);
  if (!usersSheet) {
    usersSheet = ss.insertSheet(SHEET_USERS);
    usersSheet.appendRow(['id', 'username', 'password', 'fullName', 'role', 'createdAt', 'updatedAt']);
    // Add default admin
    const adminId = Utilities.getUuid();
    usersSheet.appendRow([adminId, 'admin', 'admin1234', 'Administrator', 'admin', new Date(), new Date()]);
  }
  
  // 2. Setup Sheet: Categories
  let categoriesSheet = ss.getSheetByName(SHEET_CATEGORIES);
  if (!categoriesSheet) {
    categoriesSheet = ss.insertSheet(SHEET_CATEGORIES);
    categoriesSheet.appendRow(['id', 'name', 'createdAt', 'updatedAt']);
  }
  
  // 3. Setup Sheet: Documents
  let docsSheet = ss.getSheetByName(SHEET_DOCUMENTS);
  if (!docsSheet) {
    docsSheet = ss.insertSheet(SHEET_DOCUMENTS);
    docsSheet.appendRow([
      'id', 'docNumber', 'categoryId', 'subject', 'department', 
      'docDate', 'fiscalYear', 'responsible', 'ownerId', 'ownerName', 
      'fileIds', 'createdAt', 'updatedAt'  // fileIds will be JSON string
    ]);
  }
  
  // 4. Setup Drive Folder
  const folders = DriveApp.getFoldersByName(FOLDER_NAME);
  let folder;
  if (folders.hasNext()) {
    folder = folders.next();
  } else {
    folder = DriveApp.createFolder(FOLDER_NAME);
  }
  SCRIPT_PROP.setProperty('ATTACHMENT_FOLDER_ID', folder.getId());
  
  return 'Setup Complete';
}

function getFolderId() {
  let id = SCRIPT_PROP.getProperty('ATTACHMENT_FOLDER_ID');
  if (!id) {
    setup(); // Retry setup if property missing
    id = SCRIPT_PROP.getProperty('ATTACHMENT_FOLDER_ID');
  }
  return id;
}

// ==================== Helper Functions ====================
function _formatDate(dateObj) {
  if (!dateObj) return '';
  return Utilities.formatDate(new Date(dateObj), 'GMT+7', 'yyyy-MM-dd');
}

function _getDataFromSheet(sheetName) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(sheetName);
  if (!sheet) return [];
  
  const data = sheet.getDataRange().getValues();
  const headers = data.shift(); // Remove header row
  
  if (data.length === 0) return [];
  
  return data.map(row => {
    let obj = {};
    headers.forEach((header, index) => {
      // Handle Date fields specifically
      if (['createdAt', 'updatedAt', 'docDate'].includes(header) && row[index]) {
        obj[header] = _formatDate(row[index]);
      } else if (['id', 'ownerId', 'username', 'password'].includes(header)) {
        obj[header] = String(row[index] || '').trim();
      } else {
        obj[header] = row[index];
      }
    });
    return obj;
  });
}

function _saveToSheet(sheetName, dataObj, idField = 'id') {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(sheetName);
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  
  let rowIndex = -1;
  // Check if updating existing row
  if (dataObj[idField]) {
    for (let i = 1; i < data.length; i++) {
      if (data[i][headers.indexOf(idField)] == dataObj[idField]) {
        rowIndex = i + 1; // 1-based index
        break;
      }
    }
  }
  
  const rowData = headers.map(header => {
    if (header === 'updatedAt') return new Date();
    if (header === 'createdAt' && rowIndex === -1) return new Date();
    if (header === 'createdAt' && rowIndex !== -1) return null; // Preserve original createdAt (handled by not overwriting if we read first, but here we construct fresh)
    // Actually simpler: just use dataObj values.
    return dataObj[header] !== undefined ? dataObj[header] : '';
  });

  // If preserving old data is needed, we should read the old row. 
  // Simplified strategy for this assignment: Assume dataObj has all needed fields or we overwrite.
  // Exception: 'createdAt' should be preserved if update.
  if (rowIndex !== -1) {
    // Preserve createdAt
    const createdAtIndex = headers.indexOf('createdAt');
    if (createdAtIndex !== -1) {
      rowData[createdAtIndex] = sheet.getRange(rowIndex, createdAtIndex + 1).getValue();
    }
    
    // Write row
    sheet.getRange(rowIndex, 1, 1, rowData.length).setValues([rowData]);
  } else {
    // Append
    // Add ID if missing
    if (!dataObj[idField]) {
      const idIndex = headers.indexOf(idField);
      if (idIndex !== -1) rowData[idIndex] = Utilities.getUuid();
    }
    sheet.appendRow(rowData);
  }
}

function _deleteFromSheet(sheetName, id, idField = 'id') {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(sheetName);
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const idIndex = headers.indexOf(idField);
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][idIndex] == id) {
      sheet.deleteRow(i + 1);
      return true;
    }
  }
  return false;
}

// ==================== User Functions ====================
function getUsers() {
  return _getDataFromSheet(SHEET_USERS);
}

function saveUser(user) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(SHEET_USERS);
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  // Check duplicates if new
  if (!user.id) {
    const users = getUsers();
    if (users.find(u => u.username === user.username)) {
      throw new Error('ชื่อผู้ใช้นี้มีอยู่ในระบบแล้ว');
    }
    user.id = Utilities.getUuid();
    user.createdAt = new Date();
  }
  user.updatedAt = new Date();
  
  _saveToSheet(SHEET_USERS, user);
  return getUsers();
}

function deleteUser(userId) {
  _deleteFromSheet(SHEET_USERS, userId);
  return getUsers();
}

// ==================== Category Functions ====================
function getCategories() {
  return _getDataFromSheet(SHEET_CATEGORIES);
}

function saveCategory(category) {
  if (!category.id) {
    category.id = Utilities.getUuid();
    category.createdAt = new Date();
  }
  category.updatedAt = new Date();
  
  // Force plain text for category name
  if (category.name !== undefined && category.name !== null) {
    const val = String(category.name);
    if (!val.startsWith("'")) {
      category.name = "'" + val;
    }
  }

  _saveToSheet(SHEET_CATEGORIES, category);
  return getCategories();
}

function deleteCategory(categoryId) {
  _deleteFromSheet(SHEET_CATEGORIES, categoryId);
  return getCategories();
}

// ==================== Document Functions ====================
function getDocuments() {
  const docs = _getDataFromSheet(SHEET_DOCUMENTS);
  const categories = getCategories(); // Join for category name if needed, but client does it currently.
  
  // Parse fileIds JSON and add URLs
  return docs.map(doc => {
    let files = [];
    try {
      if (doc.fileIds) {
        const fileMeta = JSON.parse(doc.fileIds);
        files = fileMeta.map(f => ({
          name: f.name,
          type: f.type,
          id: f.id,
          // Generate a download/view URL
          // Using a small helper to get Base64 or just a link. 
          // For this requirement: "files associated" - usually we store ID.
          // The client expects 'data' (Base64) for preview, or a link.
          // Returning data URI for small files is heavy.
          // Better: Return a Google Drive thumbnail or download URL.
          // For now, let's keep it compatible with the client logic which seems to use Data URI.
          // BUT: Sending Data URIs for all docs is bad performance.
          // Let's modify client to handle URLs.
          // However, user said "Don't use fetch". 
          // Client code uses "files.map... <a href='${file.data}'".
          // If we want to view, we should use Drive View URL.
          url: _getFileUrl(f.id),
          data: _getFileUrl(f.id) // Replacing Base64 data with URL for download link
        }));
      }
    } catch (e) {
      console.error('Error parsing fileIds', e);
    }
    
    // Transform formatting
    doc.files = files;
    
    // Handle Date fields for strict yyyy-mm-dd format
    if (doc.docDate) doc.docDate = _formatDate(doc.docDate);
    if (doc.createdAt) doc.createdAt = _formatDate(doc.createdAt);
    if (doc.updatedAt) doc.updatedAt = _formatDate(doc.updatedAt);
    
    return doc;
  });
}

function saveDocument(docData, filesData) {
  // handling file uploads
  const folderId = getFolderId();
  const folder = DriveApp.getFolderById(folderId);
  
  let currentFiles = [];
  // If editing, retrieve existing files first?
  // Simpler: Client sends current file list. 
  // But wait, client sends Base64 for new files.
  // We need to saving text 'fileIds' array in sheet: [{id, name, type}, ...]
  
  // 1. Process new uploads
  let savedFilesMeta = [];
  
  if (filesData && filesData.length > 0) {
    filesData.forEach(file => {
      if (file.data && file.data.startsWith('data:')) {
        // It's a new Base64 file
        const contentType = file.data.substring(5, file.data.indexOf(';'));
        const base64 = file.data.substring(file.data.indexOf(',') + 1);
        const blob = Utilities.newBlob(Utilities.base64Decode(base64), contentType, file.name);
        const driveFile = folder.createFile(blob);
        driveFile.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
        
        savedFilesMeta.push({
          id: driveFile.getId(),
          name: file.name,
          type: file.type
        });
      } else if (file.id) {
        // Existing file, keep it
        savedFilesMeta.push({
          id: file.id,
          name: file.name,
          type: file.type
        });
      }
    });
  }
  
  docData.fileIds = JSON.stringify(savedFilesMeta);
  delete docData.files; // Don't save this large/object field directly to column
  
  // Force plain text for specific fields
  const plainTextFields = ['docNumber', 'subject', 'department', 'fiscalYear', 'responsible', 'ownerName'];
  plainTextFields.forEach(field => {
    if (docData[field] !== undefined && docData[field] !== null) {
      // Prefix with ' to ensure Google Sheets treats it as text
      const val = String(docData[field]);
      if (!val.startsWith("'")) {
        docData[field] = "'" + val;
      }
    }
  });
  
  if (!docData.id) {
    docData.id = Utilities.getUuid();
    docData.createdAt = new Date();
  }
  docData.updatedAt = new Date();
  
  // Ensure date object for sheets
  if (docData.docDate) {
    docData.docDate = new Date(docData.docDate);
  } else {
    docData.docDate = '';
  }

  _saveToSheet(SHEET_DOCUMENTS, docData);
  return getDocuments();
}

function deleteDocument(docId) {
  // Optional: Delete files from Drive too?
  // keeping it simple mainly Sheet deletion
  _deleteFromSheet(SHEET_DOCUMENTS, docId);
  return getDocuments();
}

function _getFileUrl(fileId) {
  try {
    return DriveApp.getFileById(fileId).getDownloadUrl();
  } catch (e) {
    return '#';
  }
}

